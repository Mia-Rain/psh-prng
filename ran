#!/bin/sh
mseed() {
  [ -c /dev/urandom -a ! "$PID" ] && {
    read -r seed < /dev/urandom # read a single line of urandom
    seed=${#seed}
  } || { # otherwise generate a seed using pids
  # $PID may be set to force usage of pids
    : & wait; o="$!"; for i in 1 2 3 4 5; do
      : & wait # generate new $!
      o=$((o%o+$!*o))
    done
    for i in 1 2 3; do
      : & wait
    done
    seed="$((o%o+$!*${#o}))" # greatly shorten seed
    # large seeds produce large numbers = more randomness
  }
  # L105
  [ -c /dev/urandom ] && {
    read -r o < /dev/urandom
    o="${#o}"
  } || {
    # warn about lack of hardware randomness
    : & wait
    o="$!" # pid is "RANDOM"
    for i in 1 2 3; do
      : & wait
    done # 3 pid calls
    o="$((o%o*o+$!))" # this allows the last digit to actually be random
  } 
  : $((seed+=o))
  # use $o to add possibility of odd number
}
# make seed ^
# ripped from master branch
unset s0 s1 seed
case "$1" in
  "") mseed && s0=$seed ;;
  *) s0=$1
esac
case "$2" in
  "") mseed && s1=$seed ;;
  *) s1=$2
esac
# allow for manual seed ^

# an attempt at xoroshiro64** follows
# this is based off the reference code @ https://prng.di.unimi.it/xoroshiro64starstar.c
# keep in mind I have no idea how most of this works
rotl() {
  echo $(( ($1 << $2) | ( $1 >> (32 - $2) ) ))
} # return (x << k) | (x >> (32 - k))
next() {
  # s0/s1 are generated above @ L42-49
  : $((s1 ^= s0))
  s0=$(($(rotl s0 26) ^ s1 ^ (s1 << 9)))
  s1=$(rotl $s1 13)
  echo $(($(rotl $((s0*0x9E3779BB)) 5)*5)) # result
}
o=$(next); echo 0.${o#-}
