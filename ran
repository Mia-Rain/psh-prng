#!/bin/sh
[ -c /dev/urandom ] && {
  read -r seed < /dev/urandom # read a single line of urandom
  seed=${#seed}
} || { # otherwise generate a seed by counting stuff
  n=0;
  [ -x /bin/ ] && { # if we can access /bin count the files in it
    for i in /bin/*; do
      [ -f "$i" ] && : $((n+=1))
    done
  }
  [ -x /tmp/ ] && {
    for i in /tmp/*; do
      [ -e "$i" ] && : $((n+=1))
    done
  }
  [ -x /var/ ] && {
    for i in /var/*; do
      [ -e "$i" ] && : $((n+=1))
    done
  }
  : $((n+=${#PWD})); : $((n+=${#0}))
  seed="${n:-100}"
}
[ "$1" ] && seed="$1" # allow a seed to be set via $1
# $seed should now contain a number
# the idea here is the $seed should be /slightly/ random or at least dicated by the contents of the current systen
# now we must remove all possible leading 0's
until [ ${seed#0} = $seed ]; do
  seed=${seed#0}
done
# echo "being LCG"
# LCG imp follows
# generate a modulus (m) from the length of $seed and then detemine if its a prime
m="$(( ${#seed} * 65536))"; [ "$((m%2))" -eq 0 -o "$((m%3))" -eq 0 -a "$m" -gt 2 -a "$m" -gt 3 ] || : $((m+=1)) # if prime
# 65536 is 2^16; causing the seed to be some multiple of 2^<> causes an increase in randomness from my basic testing
# a smarter way might be to have an index of powers of 2; then add 10 to $m and multiply its orginal value based upon the same power it pulls from the index
#                           ^ if not a multiple of 2 or 3 expect the number to be prime and increase it by 1
# typically we want $m to be a power of 2; the larger the better; however (2^63)-1 is the max size dash can hold before an overflow happens
# ie $(( 4611686018427387904*2 )) produces -9223372036854775808; this is correct, minus the leading -
# any operations on this number that should produce a larger number cause said number to act as if it was a negative
# note that $(( 4611686018427387904*2 -1)) does infact produce (2^63)-1; adding even 1 to this results in an overflow
##
# if we do infact want to make $m a power of to, the simplest process is an until loop
# $((x&(x-1))) where x is $m will produce 0 if x/$m is a power of 2
# the below works perfectly; however, requiring $m to be a power of 2 causes $seed to produce a pattern
#until [ "$((m&(m-1)))" -eq 0 ]; do
#  : $((m+=1))
#done
p=0 # $p is the next prime and can be determined using a while loop that adds 1 to it until it becomes a prime
#echo "determine modulus and its factors"
if [ $((m%2)) -eq 0 ]; then # now determine the prime factors of $m
  f=$((m/2)) # next prime is 3; 5
  p=2
  until [ $((f % 2)) -gt 0 -a $(( f % 3)) -gt 0 ]; do
    [ $((f%p)) -eq 0 ] && {
      f=$((f/p))
    } || {
      : $((p+=1))
      until [ $((p%2)) -gt 0 -a $((p%3)) -gt 0 ] || [ "$p" -eq 2 -o "$p" -eq 3 ]; do
        : $((p+=1))
      done
    }
  done
elif [ $((m%3)) -eq 0 ]; then
  f=$((m/3)) # next prime is 5; 7
  p=3
  until [ $((f % 2)) -gt 0 -a $((f % 3)) -gt 0 ]; do
    [ $((f%p)) -eq 0 ] && {
      f=$((f/p))
    } || {
      : $((p+=1)); until [ $((p%2)) -gt 0 -a $((p%3)) -gt 0 ] || [ "$p" -eq 2 -o "$p" -eq 3 ]; do
        : $((p+=1))
      done
    }
  done # until $f is prime do the above
fi # $f is the prime factor of $m; $f*2 = $m
if [ "$seed" -gt 75 ]; then
  a="$((seed-75))" # here the multiplier (a) is seed (z) - 75 # the 75 here is taken from the ZX81's multiplier (a) from its own LCG
elif [ "$seed" -gt 6 ]; then # the 6 here for fallback is literally random
  a="$((seed-6))"
fi
until [ "$(( (a-1)%f ))" -eq 0 ]; do # the multiplier (a) -1 MUST be a multiple of $f
  : $((a+=1)) # add to a until a-1 is a multiple of $f
done
# increment (c) and the modulus (m) must be co-prime; and two random primes should be co-prime therefore set $c to $p; see above
# the final digit used by LCG will be the seed (z) # z & c will not be defined to save on memory
seed=$(( ((a*seed)+p)%m )) # finally calculate a need seed via the formula: (a*z + c)%m and return it
echo "$seed"
